<!DOCTYPE html>
<html lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ã‚Œã‚“ã—ã‚…ã†</title>

<style>
  body {
    text-align: center;
    font-family: "UDDigiKyokasho", "Noto Sans JP", sans-serif;
    background: #fff6e0;
    margin: 0;
    padding: 20px;
    overflow: hidden;
  }

  @font-face {
    font-family: "UDDigiKyokasho";
    src: url("https://fonts.gstatic.com/ea/uddigikyokasho/v1/UDDigiKyokashoN-R.woff2") format("woff2");
  }

  #backBtn {
    position: fixed;
    top: 10px;
    left: 10px;
    background: #4c8f3a;
    color: white;
    padding: 10px 15px;
    border-radius: 20px;
    text-decoration: none;
    z-index: 10;
    touch-action: auto;
  }

  #progress {
    font-size: 22px;
    color: #4c8f3a;
    margin-top: 10px;
    font-weight: bold;
  }

  #canvas-container {
    position: relative;
    width: 300px;
    height: 300px;
    margin: 0 auto;
  }

  #templateImg {
    position: absolute;
    width: 300px;
    height: 300px;
    object-fit: contain;
    opacity: 0.25;
    pointer-events: none;
    user-select: none;
  }

  #canvas {
    width: 300px;
    height: 300px;
    border: 4px solid #4c8f3a;
    background: white;
    border-radius: 20px;
    touch-action: none !important;
  }

  .btn {
    margin-top: 20px;
    padding: 15px 25px;
    background: #4c8f3a;
    color: white;
    border-radius: 10px;
    border: none;
    font-size: 22px;
    touch-action: auto !important;
    margin-left: 10px;
    margin-right: 10px;
  }

  #popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.6);
    background: white;
    padding: 25px 35px;
    border-radius: 20px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    font-size: 24px;
    color: #4c8f3a;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s, transform 0.3s;
    z-index: 50;
  }

  #popup.show {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1);
  }

  #strokeInfo {
    font-size: 18px;
    color: #4c8f3a;
    margin-top: 10px;
    min-height: 25px;
  }
</style>
</head>

<body>

<a id="backBtn" href="hiragana.html">â† ã‚‚ã©ã‚‹</a>

<h2 id="title" style="color:#4c8f3a;">ã‚ ã‚’ãªãã‚ã†ï¼</h2>
<div style="text-align:center; font-size:16px; color:#4c8f3a; margin-bottom:5px;">
  <span id="difficultyDisplay"></span>
</div>
<div id="progress">ã‚¬ãƒãƒ£ã¾ã§ï¼šã‚ã¨ 10 å›</div>
<div id="strokeInfo"></div>

<div id="canvas-container">
  <img id="templateImg" src="./practice_files/ã‚.png">
  <canvas id="canvas" width="300" height="300"></canvas>
</div>

<button class="btn" onclick="clearCanvas()">ã‚„ã‚ŠãªãŠã™</button>
<button class="btn" onclick="finishPractice()">ã§ããŸï¼</button>

<div id="popup"></div>

<audio id="okSound" src="https://www.soundjay.com/buttons/sounds/button-09.mp3"></audio>

<script src="strokeMaskData.js"></script>
<script>
/* ---------------------------
    åˆæœŸè¨­å®š
---------------------------- */
const selected = localStorage.getItem("selectedChar") || "ã‚";
const templateImg = document.getElementById("templateImg");
const canvasContainer = document.getElementById("canvas-container");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const DISPLAY_SIZE = 300; // è¡¨ç¤ºã‚µã‚¤ã‚ºã‚’300pxã«å›ºå®š

let strokeMap = new Uint8Array();
let strokePixels = [];
let totalStrokeCount = 1;
let strokeMapReady = false;
let maskWidth = 0;
let maskHeight = 0;
let scaleX = 1;
let scaleY = 1;
let offsetX = 0;
let offsetY = 0;
let currentStrokeIndex = 0;
let userStrokes = [];
let isDrawing = false;
let currentStroke = null;
let lastX = null;
let lastY = null;
let drawDistance = 0;

function updateStrokeInfo() {
  const info = document.getElementById("strokeInfo");
  if (strokeMapReady) {
    info.textContent = `${Math.min(currentStrokeIndex + 1, totalStrokeCount)} / ${totalStrokeCount} ç”»ç›®`;
  } else {
    info.textContent = "ãƒã‚¹ã‚¯ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ";
  }
}

// é›£æ˜“åº¦è¡¨ç¤º
const difficulty = localStorage.getItem('difficulty') || 'normal';
const difficultyNames = {
  'easy': 'ğŸ˜Š ã‹ã‚“ãŸã‚“',
  'normal': 'ğŸ™‚ ãµã¤ã†',
  'hard': 'ğŸ˜¤ ã‚€ãšã‹ã—ã„'
};
document.getElementById('difficultyDisplay').textContent = `ãªã‚“ã„ã©: ${difficultyNames[difficulty]}`;

// é€²æ—è¡¨ç¤ºæ›´æ–°
function updateProgress() {
  let count = Number(localStorage.getItem("practiceCount") || 0);
  const remaining = Math.max(0, 10 - count);
  document.getElementById("progress").textContent = `ã‚¬ãƒãƒ£ã¾ã§ï¼šã‚ã¨ ${remaining} å›`;
}
updateProgress();

function decodeBase64Map(base64) {
  const binary = atob(base64);
  const len = binary.length;
  const arr = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    arr[i] = binary.charCodeAt(i);
  }
  return arr;
}

function applyMaskData(char) {
  const data = window.strokeMaskData?.[char];
  if (!data) {
    strokeMapReady = false;
    totalStrokeCount = 1;
    strokeMap = new Uint8Array();
    strokePixels = [];
    internalClearCanvas();
    return;
  }

  const { width, height, strokeCount, map, strokePixels: pxCounts } = data;
  maskWidth = width;
  maskHeight = height;
  
  // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºã‚’300pxã«å›ºå®š
  canvas.width = DISPLAY_SIZE;
  canvas.height = DISPLAY_SIZE;
  
  // object-fit: contain ã‚’è€ƒæ…®ã—ãŸã‚¹ã‚±ãƒ¼ãƒ«ã¨ã‚ªãƒ•ã‚»ãƒƒãƒˆã®è¨ˆç®—
  const imageAspect = width / height;
  const containerAspect = DISPLAY_SIZE / DISPLAY_SIZE;
  
  let displayWidth, displayHeight;
  if (imageAspect > containerAspect) {
    // å¹…åŸºæº–ã§ç¸®å°
    displayWidth = DISPLAY_SIZE;
    displayHeight = DISPLAY_SIZE / imageAspect;
    offsetX = 0;
    offsetY = (DISPLAY_SIZE - displayHeight) / 2;
  } else {
    // é«˜ã•åŸºæº–ã§ç¸®å°
    displayHeight = DISPLAY_SIZE;
    displayWidth = DISPLAY_SIZE * imageAspect;
    offsetX = (DISPLAY_SIZE - displayWidth) / 2;
    offsetY = 0;
  }
  
  // ã‚¹ã‚±ãƒ¼ãƒ«å¤‰æ›ã®è¨ˆç®—ï¼ˆè¡¨ç¤ºã‚µã‚¤ã‚º â†’ ãƒã‚¹ã‚¯ã‚µã‚¤ã‚ºï¼‰
  scaleX = width / displayWidth;
  scaleY = height / displayHeight;

  strokeMap = decodeBase64Map(map);
  strokePixels = pxCounts.slice();
  totalStrokeCount = strokeCount || strokePixels.length || 1;
  strokeMapReady = true;
  internalClearCanvas();
}

function loadCharacter(char) {
  document.getElementById("title").textContent = `${char} ã‚’ãªãã‚ã†ï¼`;
  applyMaskData(char);
  templateImg.src = `./practice_files/${char}.png`;
}

loadCharacter(selected);

/* ---------------------------
    æç”»ç³»
---------------------------- */

canvas.addEventListener("pointerdown", e => {
  if (currentStrokeIndex >= totalStrokeCount) {
    return;
  }
  
  isDrawing = true;
  const rect = canvas.getBoundingClientRect();
  lastX = e.clientX - rect.left;
  lastY = e.clientY - rect.top;
  
  // æ–°ã—ã„ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã‚’é–‹å§‹
  currentStroke = {
    startX: lastX,
    startY: lastY,
    points: [{ x: lastX, y: lastY }]
  };
  
  ctx.beginPath();
  ctx.moveTo(lastX, lastY);
});

canvas.addEventListener("pointerup", () => {
  if (!isDrawing) return;
  
  isDrawing = false;
  
  if (currentStroke && currentStroke.points.length > 0) {
    // ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã®çµ‚äº†ä½ç½®ã‚’è¨˜éŒ²
    const lastPoint = currentStroke.points[currentStroke.points.length - 1];
    currentStroke.endX = lastPoint.x;
    currentStroke.endY = lastPoint.y;
    
    // æ›¸ãé †åˆ¤å®š
    const isValid = validateStroke(currentStroke, currentStrokeIndex);
    
    if (isValid) {
      userStrokes.push(currentStroke);
      currentStrokeIndex++;
      updateStrokeInfo();
      
      if (currentStrokeIndex >= totalStrokeCount) {
        // ã™ã¹ã¦ã®ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ãŒå®Œäº†ã—ãŸã‚‰è‡ªå‹•çš„ã«ã‚«ã‚¦ãƒ³ãƒˆå‡¦ç†
        handlePracticeComplete();
      } else {
        showPopup(`æ­£ã—ã„æ›¸ãé †ã§ã™ï¼æ¬¡ã¯ ${currentStrokeIndex + 1} ç”»ç›®ã§ã™`);
      }
    } else {
      showPopup("æ›¸ãé †ãŒé•ã„ã¾ã™ã€‚ã‚‚ã†ä¸€åº¦è©¦ã—ã¦ãã ã•ã„ã€‚");
      // é–“é•ã£ãŸã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã‚’æ¶ˆå»
      clearCanvas();
      // æ­£ã—ãæ›¸ã‹ã‚ŒãŸã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã‚’å†æç”»
      redrawValidStrokes();
    }
    
    currentStroke = null;
  }
  
  ctx.beginPath();
});

canvas.addEventListener("pointermove", e => {
  if (!isDrawing) return;

  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  const dx = x - lastX;
  const dy = y - lastY;
  drawDistance += Math.sqrt(dx*dx + dy*dy);

  if (currentStroke) {
    currentStroke.points.push({ x, y });
  }

  ctx.lineWidth = 12;
  ctx.lineCap = "round";
  ctx.strokeStyle = "#4c8f3a";

  ctx.lineTo(x, y);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(x, y);

  lastX = x;
  lastY = y;
});

/* ---------------------------
   æ›¸ãé †åˆ¤å®š
---------------------------- */
function validateStroke(stroke, strokeIndex) {
  if (!strokeMapReady) {
    return stroke.points.length > 0;
  }

  const expectedStroke = strokeIndex + 1;
  let matches = 0;

  stroke.points.forEach(({ x, y }) => {
    // è¡¨ç¤ºåº§æ¨™ã‚’ãƒã‚¹ã‚¯åº§æ¨™ã«å¤‰æ›ï¼ˆã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è€ƒæ…®ï¼‰
    const adjustedX = x - offsetX;
    const adjustedY = y - offsetY;
    const px = Math.round(adjustedX * scaleX);
    const py = Math.round(adjustedY * scaleY);
    if (px < 0 || px >= maskWidth || py < 0 || py >= maskHeight) {
      return;
    }
    const idx = strokeMap[py * maskWidth + px];
    if (idx === expectedStroke) {
      matches++;
    }
  });

  const total = Math.max(1, stroke.points.length);
  const ratio = matches / total;
  const strokePixelTotal = strokePixels[strokeIndex] || 1;
  const coverage = matches / strokePixelTotal;

  // é›£æ˜“åº¦ã«å¿œã˜ãŸåˆ¤å®šåŸºæº–
  const difficulty = localStorage.getItem('difficulty') || 'normal';
  let ratioThreshold, coverageThreshold;
  
  switch(difficulty) {
    case 'easy':
      ratioThreshold = 0.15;    // 15%ã®ãƒã‚¤ãƒ³ãƒˆãŒæ­£ã—ã„é ˜åŸŸã«é‡ãªã‚Œã°OK
      coverageThreshold = 0.03;  // 3%ã®ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã‚’ã‚«ãƒãƒ¼ã™ã‚Œã°OK
      break;
    case 'hard':
      ratioThreshold = 0.35;    // 35%ã®ãƒã‚¤ãƒ³ãƒˆãŒæ­£ã—ã„é ˜åŸŸã«é‡ãªã‚‹å¿…è¦ãŒã‚ã‚‹
      coverageThreshold = 0.08;  // 8%ã®ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã‚’ã‚«ãƒãƒ¼ã™ã‚‹å¿…è¦ãŒã‚ã‚‹
      break;
    case 'normal':
    default:
      ratioThreshold = 0.25;    // 25%ã®ãƒã‚¤ãƒ³ãƒˆãŒæ­£ã—ã„é ˜åŸŸã«é‡ãªã‚Œã°OK
      coverageThreshold = 0.05;  // 5%ã®ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã‚’ã‚«ãƒãƒ¼ã™ã‚Œã°OK
  }

  // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’è¡¨ç¤º
  console.log('=== æ›¸ãé †åˆ¤å®šãƒ‡ãƒãƒƒã‚° ===');
  console.log(`æ–‡å­—: ${selected}, ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯: ${strokeIndex + 1}ç”»ç›®`);
  console.log(`ãƒã‚¹ã‚¯ã‚µã‚¤ã‚º: ${maskWidth}x${maskHeight}px`);
  console.log(`ã‚¹ã‚±ãƒ¼ãƒ«: X=${scaleX.toFixed(3)}, Y=${scaleY.toFixed(3)}`);
  console.log(`ã‚ªãƒ•ã‚»ãƒƒãƒˆ: X=${offsetX.toFixed(1)}px, Y=${offsetY.toFixed(1)}px`);
  console.log(`æç”»ãƒã‚¤ãƒ³ãƒˆæ•°: ${total}å€‹`);
  console.log(`æ­£ã—ã„é ˜åŸŸã«é‡ãªã£ãŸãƒã‚¤ãƒ³ãƒˆ: ${matches}å€‹`);
  console.log(`é‡ãªã‚Šç‡: ${(ratio * 100).toFixed(1)}% (å¿…è¦: ${(ratioThreshold * 100).toFixed(1)}%)`);
  console.log(`ã‚«ãƒãƒ¼ç‡: ${(coverage * 100).toFixed(1)}% (å¿…è¦: ${(coverageThreshold * 100).toFixed(1)}%)`);
  console.log(`ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ç·ãƒ”ã‚¯ã‚»ãƒ«æ•°: ${strokePixelTotal}px`);
  console.log(`é›£æ˜“åº¦: ${difficulty}`);
  
  // ã‚µãƒ³ãƒ—ãƒ«ãƒã‚¤ãƒ³ãƒˆã®å¤‰æ›ä¾‹ã‚’è¡¨ç¤º
  if (stroke.points.length > 0) {
    const first = stroke.points[0];
    const last = stroke.points[stroke.points.length - 1];
    console.log(`é–‹å§‹ç‚¹: è¡¨ç¤º(${first.x.toFixed(0)}, ${first.y.toFixed(0)}) â†’ ãƒã‚¹ã‚¯(${Math.round((first.x - offsetX) * scaleX)}, ${Math.round((first.y - offsetY) * scaleY)})`);
    console.log(`çµ‚äº†ç‚¹: è¡¨ç¤º(${last.x.toFixed(0)}, ${last.y.toFixed(0)}) â†’ ãƒã‚¹ã‚¯(${Math.round((last.x - offsetX) * scaleX)}, ${Math.round((last.y - offsetY) * scaleY)})`);
  }
  
  console.log(`åˆ¤å®šçµæœ: ${ratio >= ratioThreshold || coverage >= coverageThreshold ? 'âœ… åˆæ ¼' : 'âŒ ä¸åˆæ ¼'}`);
  console.log('===================');

  return ratio >= ratioThreshold || coverage >= coverageThreshold;
}

/* ---------------------------
   æ­£ã—ãæ›¸ã‹ã‚ŒãŸã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ã‚’å†æç”»
---------------------------- */
function redrawValidStrokes() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  ctx.lineWidth = 12;
  ctx.lineCap = "round";
  ctx.strokeStyle = "#4c8f3a";
  
  userStrokes.forEach(stroke => {
    if (stroke.points.length > 0) {
      ctx.beginPath();
      ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
      
      for (let i = 1; i < stroke.points.length; i++) {
        ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
      }
      
      ctx.stroke();
    }
  });
}

/* ---------------------------
   ã‚­ãƒ£ãƒ³ãƒã‚¹æ¶ˆå»
---------------------------- */
function internalClearCanvas() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawDistance = 0;
  currentStrokeIndex = 0;
  userStrokes = [];
  currentStroke = null;
  updateStrokeInfo();
}

function clearCanvas() {
  internalClearCanvas();
}

/* ---------------------------
   ãƒãƒƒãƒ—æ¼”å‡º
---------------------------- */
function showPopup(text) {
  const popup = document.getElementById("popup");
  popup.textContent = text;
  popup.classList.add("show");
  setTimeout(() => popup.classList.remove("show"), 2000);
}

/* ---------------------------
   å…¨ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯å®Œäº†æ™‚ã®å‡¦ç†
---------------------------- */
function handlePracticeComplete() {
  // åŠ¹æœéŸ³ã‚’å†ç”Ÿ
  document.getElementById("okSound").play().catch(() => {});
  
  // ç·´ç¿’ã‚«ã‚¦ãƒ³ãƒˆã‚’å¢—ã‚„ã™
  let count = Number(localStorage.getItem("practiceCount") || 0);
  count++;
  localStorage.setItem("practiceCount", count);
  
  updateProgress();
  
  // 10å›æœªé”æˆã®å ´åˆ
  if (count < 10) {
    showPopup(`ã™ã”ã„ï¼ğŸ¦– ã‚¬ãƒãƒ£ã¾ã§ ã‚ã¨ ${10 - count} å›ï¼`);
    setTimeout(() => {
      clearCanvas();
    }, 2000);
    return;
  }
  
  // 10å›é”æˆ
  localStorage.setItem("practiceCount", 10);
  showPopup("10å›é”æˆï¼ã‚¬ãƒãƒ£ã ï¼ï¼ğŸ‰ğŸ¦–");
  
  setTimeout(() => {
    location.href = "gacha.html";
  }, 2000);
}

/* ---------------------------
   ã§ããŸï¼å‡¦ç†ï¼ˆæ‰‹å‹•ç¢ºèªç”¨ï¼‰
---------------------------- */
function finishPractice() {
  if (currentStrokeIndex < totalStrokeCount) {
    showPopup(`ã‚ã¨ ${totalStrokeCount - currentStrokeIndex} ç”»æ›¸ã„ã¦ãã ã•ã„`);
    return;
  }
  
  // æ›¸ã„ãŸã‹ã©ã†ã‹åˆ¤å®šï¼ˆè·é›¢ãŒä¸€å®šä»¥ä¸‹ãªã‚‰NGï¼‰
  if (drawDistance < 150) {
    showPopup("ã¾ãšã¯æ›¸ã„ã¦ã¿ã‚ˆã†ï¼âœï¸");
    return;
  }
  
  // ã™ã§ã«å…¨ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯å®Œäº†ã—ã¦ã„ã‚‹å ´åˆã¯ã€å†åº¦ã‚«ã‚¦ãƒ³ãƒˆå‡¦ç†
  handlePracticeComplete();
}
</script>

</body>
</html>

